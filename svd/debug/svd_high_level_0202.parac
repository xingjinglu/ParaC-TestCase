#define M 256
#define N 256
#define ROWS 256
#define COLS 256
#
#define TYPE double

#define MAX_ITERATIONS 40
#define THRESHOLD 0.00001

#define FLAG 1
#define IN_PRODUCT 0

__inline double  sig(double v)
{
    if(v == 0) return 0;

    if(v > 0) return 1;

    return -1;
}

//仅用于测试新语言，仅更新A
void svd(matrix complex double &A[ROWS][COLS], vector double &S[COLS], matrix complex double &V[ROWS][COLS])
{
    int pass;
    int iterations_passed = 0;
    
    //初始化列索引
    matrix complex double A_H[COLS][ROWS];
    matrix complex double V_H[COLS][ROWS];	

    //
    // init index.
    vector int rotate_col_idx[COLS];
    for(int i = 0; i < COLS; i++)
        rotate_col_idx[i] = i;
   
    int iteration = MAX_ITERATIONS;
    int start_index, skip_trans;
    while(iteration > 0)
    {
      //判断程序是否收敛

      for(int i = 0; i < COLS; i++)
      {
        //判断是奇数阶段还是偶数阶段，如果是偶数阶段，从第0个索引开始，否则从第1个索引开始
        start_index = (i % 2 == 0) ? 0 : 1;

        iterator it(iter_col; start_index:COLS:2)
        {

        if ( i == 0 && itx == 0 ) pass = 1;
          //获取需要进行正交变换的两列
          int col_p = rotate_col_idx[itx];
          int col_q = rotate_col_idx[itx+1];

          vector complex double &ci[COLS] = A_H[col_p][*];				
          vector complex double &cj[COLS] = A_H[col_q][*];

//          complex double Goal = {0, 1.2};
//          complex double Aim;

          //判断两列是否正交
          complex double value = inner_product(ci,cj);
          double value_abs = complex_norm(value);

            if(value_abs >= THRESHOLD)
            {
              //SVD 列列变换
              pass = 0;

              double a = value.i, b=value.r;
              //TODO
              TYPE s_a2b2 = sig(b) * sqrt(a * a + b * b);
              TYPE sin_alpha = a / s_a2b2;
              TYPE cos_alpha = b / s_a2b2;
              TYPE m = -1 * (b * cos_alpha + a * sin_alpha);

              double part_value = part_product (ci, cj);

              TYPE n = 0.5 * part_value;
              //TODO
              TYPE w = sig(n) * m / sqrt(m*m + n*n);

              TYPE sin_x = w/sqrt(2 * (1 + sqrt(1 - w * w)));
              TYPE cos_x = sqrt(1 - sin_x * sin_x);

              vector complex double mid_result[COLS], mid_result1[COLS];

              //TODO
              complex double d = {0, 1};

              mid_result  = ci * cos_x + cj * cos_alpha * sin_x - d * cj * sin_alpha * sin_x;
              mid_result1 = cj * cos_x - ci * cos_alpha * sin_x - d * ci * sin_alpha * sin_x;

              A_H[col_p][*] = mid_result;
              A_H[col_q][*] = mid_result1;

              vector complex double &vi[COLS] = V_H[col_p][*];				
              vector complex double &vj[COLS] = V_H[col_q][*];

              //TODO
              mid_result  = vi * cos_x + vj * cos_alpha * sin_x - d * vj * sin_alpha * sin_x;
              mid_result1 = vj * cos_x - vi * cos_alpha * sin_x - d * vi * sin_alpha * sin_x;

              V_H[col_p][*] = mid_result;
              V_H[col_q][*] = mid_result1;
            }

          rotate_col_idx[itx] = col_q; // bugs? j-1
          rotate_col_idx[itx+1] = col_p;
        }
      }

      iteration--;
      if(pass == 1)
        break;
    }
	
	iterator it2(iter_col; 0:COLS:1)
	{
    vector complex double &ci[COLS] = A_H[it2x][*];
    double norm_A = sqrt(complex_norm(inner_product(ci,ci)));

    S[it2x] = norm_A;	

    (ci) = (ci)/norm_A;
  }	
}

int main()
{
	double *data; // = data_in_memory;//data_in_memory 为分解矩阵的数据,复数存数方式为分离存储
  //TODO
  double *V = (double*)malloc(sizeof(double)*M*N*2);

  memset(V, 0, M*N*2*sizeof(double));
  for(int i = 0; i < N i++)
        V[i*N+i]=1.0f;
	
	matrix complex double A[M][N]; // = data;
	matrix complex double V[M][N];
	vector double S[N];

 memset(V, 0, ROWS*COLS*2*sizeof(double));
 for(int i = 0; i < 256; i++)
        V[i*256+i]=1.0f;
	
	svd(A, S, V);
}
