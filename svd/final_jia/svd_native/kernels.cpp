// This file is auto-generated. Do not edit!
const char* svd="#define TYPE double\n"
"#define THRESHOLD 0.00001\n"
"\n"
"\n"
"#define ROWS 256\n"
"#define COLS 256\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"void inner_product(TYPE p_real, TYPE p_imag, TYPE q_real, TYPE q_imag,\n"
"                   __local TYPE *result, __local TYPE *result1, int l_idx) {    \n"
"\n"
"    result[l_idx]  = p_real * q_real + p_imag * q_imag;\n"
"    result1[l_idx] = p_real * q_imag - p_imag * q_real;\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"\n"
"\n"
"\n"
"\n"
"\n"
"    if(l_idx < 128) \n"
"        result[l_idx] += result[l_idx + 128];\n"
"    if(l_idx >= 128) \n"
"        result1[l_idx -128] += result1[l_idx - 128 + 128];\n"
"\n"
"     barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"\n"
"    if(l_idx < 64) \n"
"        result[l_idx] += result[l_idx + 64];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 32) \n"
"        result[l_idx] += result[l_idx + 32];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 16) \n"
"        result[l_idx] += result[l_idx + 16];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 8) \n"
"        result[l_idx] += result[l_idx + 8];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 4) \n"
"        result[l_idx] += result[l_idx + 4];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 2) \n"
"        result[l_idx] += result[l_idx + 2]; \n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 1) \n"
"        result[l_idx] += result[l_idx + 1]; \n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"\n"
"    if(l_idx >= 128) \n"
"    { \n"
"        if(l_idx < 192)  \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 64];\n"
"        if(l_idx < 160) \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 32];\n"
"        if(l_idx < 144) \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 16];\n"
"        if(l_idx < 136) \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 8]; \n"
"        if(l_idx < 132) \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 4]; \n"
"        if(l_idx < 130) \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 2]; \n"
"        if(l_idx < 129) \n"
"            result1[l_idx - 128] += result1[l_idx - 128 + 1]; \n"
"    } \n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"} \n"
"\n"
"void part_product(TYPE p_real, TYPE p_imag, TYPE q_real, TYPE q_imag,\n"
"                  __local TYPE *result, int l_idx) {    \n"
"\n"
"    result[l_idx]  = q_real * q_real +  q_imag * q_imag - p_real * p_real -  p_imag * p_imag; \n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"\n"
"\n"
"\n"
"\n"
"\n"
"    if(l_idx < 128) \n"
"        result[l_idx] += result[l_idx + 128];\n"
"\n"
"     barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"\n"
"    if(l_idx < 64) \n"
"        result[l_idx] += result[l_idx + 64];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 32) \n"
"        result[l_idx] += result[l_idx + 32];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 16) \n"
"        result[l_idx] += result[l_idx + 16];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 8) \n"
"        result[l_idx] += result[l_idx + 8];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 4) \n"
"        result[l_idx] += result[l_idx + 4];\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 2) \n"
"        result[l_idx] += result[l_idx + 2]; \n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"    if(l_idx < 1) \n"
"        result[l_idx] += result[l_idx + 1]; \n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE); \n"
"} \n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void svd_op(__global TYPE *A, __global TYPE *V, __global int *row_index, __global int *is_convergence, int start_row, int init_pass) \n"
"{\n"
"    int g_idx  = get_global_id(0);\n"
"    int l_idx  = get_local_id(0);\n"
"    int gp_idx = get_group_id(0);\n"
"\n"
"\n"
"\n"
"    if((init_pass == 1) && (g_idx == 0))\n"
"        *is_convergence = 1;\n"
"\n"
"    int rows = ROWS;\n"
"    int cols = COLS;\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"    __local TYPE result[COLS];\n"
"    __local TYPE result1[COLS];\n"
"    __local int selected_rows[2];\n"
"\n"
"\n"
"\n"
"\n"
"    if((gp_idx << 1) + start_row + 1  < rows)\n"
"    {\n"
"\n"
"        if(l_idx < 2)\n"
"            selected_rows[l_idx] = row_index[start_row + (gp_idx << 1) + l_idx];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        int p_real_row_index = selected_rows[0];\n"
"        int p_imag_row_index = p_real_row_index + rows;\n"
"\n"
"        int q_real_row_index = selected_rows[1];\n"
"        int q_imag_row_index = q_real_row_index + rows;\n"
"\n"
"        TYPE p_real = A[p_real_row_index * cols + l_idx];\n"
"        TYPE p_imag = A[p_imag_row_index * cols + l_idx];\n"
"        TYPE q_real = A[q_real_row_index * cols + l_idx];\n"
"        TYPE q_imag = A[q_imag_row_index * cols + l_idx];\n"
"\n"
"        inner_product(p_real, p_imag, q_real, q_imag, result, result1, l_idx);\n"
"\n"
"        TYPE a = result1[0];\n"
"        TYPE b = result[0];\n"
"\n"
"        TYPE value = sqrt(a * a + b * b);\n"
"        if(value >= THRESHOLD)\n"
"        {\n"
"\n"
"            if(l_idx == 0)\n"
"                *is_convergence = 0;\n"
"\n"
"            int sig = (b == 0) ? 0 : (b > 0 ? 1 : -1);\n"
"            TYPE s_a2b2 = sig * sqrt(a * a + b * b);\n"
"            TYPE sin_alpha = a / s_a2b2;\n"
"            TYPE cos_alpha = b / s_a2b2;\n"
"            TYPE m = -1 * (b * cos_alpha + a * sin_alpha);\n"
"\n"
"            part_product(p_real, p_imag, q_real, q_imag, result, l_idx);\n"
"\n"
"            TYPE n = 0.5 * result[0];\n"
"            sig = (n == 0) ? 0 : (n > 0 ? 1 : -1);\n"
"            TYPE w = sig * m / sqrt(m*m + n*n);\n"
"\n"
"            TYPE sin_x = w/sqrt(2 * (1 + sqrt(1 - w * w)));\n"
"            TYPE cos_x = sqrt(1 - sin_x * sin_x);\n"
"\n"
"            A[p_real_row_index * cols + l_idx] = p_real * cos_x + q_real * cos_alpha * sin_x + q_imag * sin_alpha * sin_x;\n"
"            A[p_imag_row_index * cols + l_idx] = p_imag * cos_x + q_imag * cos_alpha * sin_x - q_real * sin_alpha * sin_x;\n"
"\n"
"            A[q_real_row_index * cols + l_idx] = q_real * cos_x - p_real * cos_alpha * sin_x + p_imag * sin_alpha * sin_x;\n"
"            A[q_imag_row_index * cols + l_idx] = q_imag * cos_x - p_imag * cos_alpha * sin_x - p_real * sin_alpha * sin_x;\n"
"\n"
"\n"
"\n"
"\n"
"            p_real = V[p_real_row_index * cols + l_idx];\n"
"            p_imag = V[p_imag_row_index * cols + l_idx];\n"
"            q_real = V[q_real_row_index * cols + l_idx];\n"
"            q_imag = V[q_imag_row_index * cols + l_idx];\n"
"\n"
"      if(g_idx == 0)\n"
"          printf(\"mid0 = %f, mid1= %f, mid2 = %f, mid3= %f\\n\", V[p_real_row_index * cols + l_idx], V[p_imag_row_index * cols + l_idx],V[q_real_row_index * cols + l_idx],V[q_imag_row_index * cols + l_idx])  ;\n"
"\n"
"            V[p_real_row_index * cols + l_idx] = p_real * cos_x + q_real * cos_alpha * sin_x + q_imag * sin_alpha * sin_x;\n"
"            V[p_imag_row_index * cols + l_idx] = p_imag * cos_x + q_imag * cos_alpha * sin_x - q_real * sin_alpha * sin_x;\n"
"\n"
"            V[q_real_row_index * cols + l_idx] = q_real * cos_x - p_real * cos_alpha * sin_x + p_imag * sin_alpha * sin_x;\n"
"            V[q_imag_row_index * cols + l_idx] = q_imag * cos_x - p_imag * cos_alpha * sin_x - p_real * sin_alpha * sin_x;\n"
"\n"
"        }\n"
"\n"
"        if(l_idx == 0)\n"
"        {\n"
"            row_index[start_row + (gp_idx << 1)] = q_real_row_index;\n"
"            row_index[start_row + (gp_idx << 1) + 1] = p_real_row_index;;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void s_comp(__global TYPE *A, __global TYPE *S)\n"
"{\n"
"    int l_idx  = get_local_id(0);\n"
"    int gp_idx = get_group_id(0);\n"
"\n"
"    int rows = ROWS;\n"
"    int cols = COLS;\n"
"\n"
"\n"
"\n"
"    __local TYPE result[COLS];\n"
"    __local TYPE result1[COLS];\n"
"\n"
"\n"
"    int A_real_row_index = gp_idx;\n"
"    int A_imag_row_index = gp_idx + rows;\n"
"\n"
"    TYPE A_real = A[A_real_row_index * cols + l_idx];\n"
"    TYPE A_imag = A[A_imag_row_index * cols + l_idx];\n"
"\n"
"\n"
"\n"
"    inner_product(A_real, A_imag, A_real, A_imag, result, result1, l_idx);\n"
"\n"
"    TYPE a = result[0];\n"
"    TYPE b = result1[0]; \n"
"\n"
"    TYPE s = sqrt(sqrt(a * a + b * b));\n"
"\n"
"    if(l_idx == 0)\n"
"        S[gp_idx] = s;\n"
"}\n"
"\n"
;
